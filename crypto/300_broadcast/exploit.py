#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import pickle
from socket import *
from binascii import unhexlify

from Crypto.Cipher import AES

HOST = 'broadcast.pwn.seccon.jp'
PORT = 8888


def get_token():
    s = socket()
    s.connect((HOST, PORT))
    return s.recv(1024).split(b'Token: ')[1]


def get_connection():
    s = socket()
    s.connect((HOST, PORT))
    s.recv(1024)
    return s


def list_post(token):
    s = get_connection()
    s.send(token + b'\x00\x00')
    return s.recv(1024)


def write_post(token, type_, content):
    s = get_connection()
    s.send(token + b'\x01' + type_ + content)
    return s.recv(1024)


def read_post(token, idx):
    s = get_connection()
    s.send(token + b'\x02' + idx)
    return s.recv(1024)


def challenge(token, message):
    s = get_connection()
    s.send(token + b'\xff' + message)
    return s.recv(1024)


def xor(s1, s2):
    assert len(s1) == len(s2)
    return bytes(c1 ^ c2 for c1, c2 in zip(s1, s2))


def pad(text):
    if len(text) % AES.block_size != 0:
        return text + b'\x00' * (AES.block_size - len(text) % AES.block_size)
    return text


def exploit():
    new_token = get_token()

    # Get notice content and MAC
    notice_content, notice_mac = pickle.loads(read_post(new_token, b'\x00')).split(b'\n\nMAC=')
    notice_mac = unhexlify(notice_mac)

    # Create message has same MAC generated by admin
    fake_content = pad(notice_content) + pad(
        xor(notice_content[:AES.block_size], notice_mac) + notice_content[AES.block_size:])

    admin_token = challenge(new_token, fake_content)  # Challenge
    flag_post = pickle.loads(read_post(admin_token, b'\x01'))  # Read flag post using admin token

    print(flag_post.decode())


if __name__ == '__main__':
    exploit()

